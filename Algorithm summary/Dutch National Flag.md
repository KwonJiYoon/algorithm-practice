### Dutch National Flag 

```
💡 배열을 세 가지 다른 색상(또는 값)으로 나누어 정렬하는 문제를 해결    
💡 이 알고리즘은 특정한 순서로 값들을 정렬하는 데 매우 효율적이며, 시간 복잡도가 𝑂(𝑛)입니다.
```

#### 📄 대표 문제    
주어진 배열은 0, 1, 2의 세 가지 값으로 이루어져 있다.   
배열은 다음과 같은 순서로 정렬해야 한다.   
* 모든 0이 배열에 앞부분에, 모든 1은 그 다음 순서에, 모든 2는 배열의 끝부분에 오도록 정렬   

#### 🖥️ 예시 코드 
```java
class Solution {
    private void swap(int i, int j, int[] nums) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void sortColors(int[] nums) {
        int r = 0, w = 0, b = nums.length - 1;
        while (w <= b) {
            if (nums[w] == 0) {
                swap(r++, w++, nums);
            } else if (nums[w] == 1) {
                w++;
            } else {
                swap(w, b--, nums);
            }
        }
    }
}

```

#### 🔥 단계별 설명 🔥   
1. 초기화 :   

    ✅ r 은 0의 시작 위치를 나타내며, 초기값은 0이다.   
    ✅ w 는 현재 요소를 탐색하는 위치를 나타내며, 초기값은 0이다.   
    ✅ b 는 2의 끝 위치를 나타내며, 초기값은 배열의 마지막 인덱스이다.   


2. 탐색 및 정렬 :   
    ✅ w가 b보다 작거나 같은 동안 반복 실행   
    ✅ nums[w]의 값에 따라 세 가지 경우로 나누어 처리   
        
    * `nums[w] == 0` : nums[r] 과 nums[w]를 교환하고, r과 w를 1씩 증가시킨다.
    * `nums[w] == 1` : w를 1 증가시킨디ㅏ.
    * `nums[w] == 2` : nums[w]와 nums[b]를 교환하고, b를 1 감소시킨다. w는 증가 ❌    

#### 👍🏻 장점    
* **_시간 복잡도_**: 𝑂(𝑛), 배열을 한 번만 순회    
* **_공간 복잡도_**: 𝑂(1), 추가적인 메모리 사용이 없음    
* **_효율성_**: 매우 효율적이며, 정렬 문제를 빠르게 해결할 수 있습니다.



